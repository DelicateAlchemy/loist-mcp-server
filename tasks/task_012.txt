# Task ID: 12
# Title: Setup Cloud Run Deployment
# Status: in-progress
# Dependencies: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
# Priority: high
# Description: Configure Docker and Google Cloud Run for production deployment with proper environment variables and security settings.
# Details:
1. Create Dockerfile for production deployment
2. Configure Google Cloud Run service
3. Setup environment variables and secrets
4. Configure HTTPS and domain mapping
5. Setup Cloud SQL connection
6. Configure GCS bucket permissions
7. Implement health checks and monitoring

```dockerfile
# Dockerfile
FROM python:3.9-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    ffmpeg \
    libpq-dev \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /app

# Copy requirements first for better caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Set environment variables
ENV PORT=8080
ENV PYTHONUNBUFFERED=1

# Run the application
CMD exec gunicorn --bind :$PORT --workers 1 --threads 8 --timeout 0 main:app
```

```yaml
# cloudbuild.yaml for CI/CD
steps:
  # Build the container image
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/mcp-music-library:$COMMIT_SHA', '.']
  
  # Push the container image to Container Registry
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/mcp-music-library:$COMMIT_SHA']
  
  # Deploy container image to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - 'mcp-music-library'
      - '--image'
      - 'gcr.io/$PROJECT_ID/mcp-music-library:$COMMIT_SHA'
      - '--region'
      - 'us-central1'
      - '--platform'
      - 'managed'
      - '--allow-unauthenticated'
      - '--memory'
      - '2Gi'
      - '--timeout'
      - '600s'
      - '--set-env-vars'
      - 'GCS_BUCKET_NAME=${_GCS_BUCKET_NAME}'
      - '--set-secrets'
      - 'BEARER_TOKEN=mcp-bearer-token:latest'
      - '--set-secrets'
      - 'DB_USER=db-user:latest,DB_PASSWORD=db-password:latest,DB_NAME=db-name:latest,DB_HOST=db-host:latest,DB_PORT=db-port:latest'

images:
  - 'gcr.io/$PROJECT_ID/mcp-music-library:$COMMIT_SHA'
```

```bash
#!/bin/bash
# setup-cloud-resources.sh

# Set project ID
PROJECT_ID="your-project-id"
gcloud config set project $PROJECT_ID

# Create GCS bucket
BUCKET_NAME="mcp-music-library-$PROJECT_ID"
gcloud storage buckets create gs://$BUCKET_NAME --location=us-central1

# Set lifecycle policy for temporary files
cat > lifecycle.json << EOL
{
  "rule": [
    {
      "action": {"type": "Delete"},
      "condition": {
        "age": 1,
        "matchesPrefix": ["temp/"]
      }
    }
  ]
}
EOL

gcloud storage buckets update gs://$BUCKET_NAME --lifecycle-file=lifecycle.json

# Create Cloud SQL instance (PostgreSQL)
gcloud sql instances create mcp-music-library-db \
    --database-version=POSTGRES_13 \
    --tier=db-f1-micro \
    --region=us-central1 \
    --storage-size=10GB \
    --storage-type=SSD \
    --backup-start-time=23:00 \
    --availability-type=zonal

# Create database
gcloud sql databases create music_library --instance=mcp-music-library-db

# Create user
DB_PASSWORD=$(openssl rand -base64 16)
gcloud sql users create music_library_user \
    --instance=mcp-music-library-db \
    --password=$DB_PASSWORD

# Store secrets in Secret Manager
gcloud secrets create mcp-bearer-token --data-file=- <<< "$(openssl rand -base64 32)"
gcloud secrets create db-user --data-file=- <<< "music_library_user"
gcloud secrets create db-password --data-file=- <<< "$DB_PASSWORD"
gcloud secrets create db-name --data-file=- <<< "music_library"
gcloud secrets create db-host --data-file=- <<< "127.0.0.1"
gcloud secrets create db-port --data-file=- <<< "5432"

# Create service account for Cloud Run
gcloud iam service-accounts create mcp-music-library-sa \
    --display-name="MCP Music Library Service Account"

# Grant permissions
gcloud projects add-iam-policy-binding $PROJECT_ID \
    --member="serviceAccount:mcp-music-library-sa@$PROJECT_ID.iam.gserviceaccount.com" \
    --role="roles/storage.objectAdmin"

gcloud projects add-iam-policy-binding $PROJECT_ID \
    --member="serviceAccount:mcp-music-library-sa@$PROJECT_ID.iam.gserviceaccount.com" \
    --role="roles/secretmanager.secretAccessor"

# Grant access to secrets
gcloud secrets add-iam-policy-binding mcp-bearer-token \
    --member="serviceAccount:mcp-music-library-sa@$PROJECT_ID.iam.gserviceaccount.com" \
    --role="roles/secretmanager.secretAccessor"

gcloud secrets add-iam-policy-binding db-user \
    --member="serviceAccount:mcp-music-library-sa@$PROJECT_ID.iam.gserviceaccount.com" \
    --role="roles/secretmanager.secretAccessor"

gcloud secrets add-iam-policy-binding db-password \
    --member="serviceAccount:mcp-music-library-sa@$PROJECT_ID.iam.gserviceaccount.com" \
    --role="roles/secretmanager.secretAccessor"

gcloud secrets add-iam-policy-binding db-name \
    --member="serviceAccount:mcp-music-library-sa@$PROJECT_ID.iam.gserviceaccount.com" \
    --role="roles/secretmanager.secretAccessor"

gcloud secrets add-iam-policy-binding db-host \
    --member="serviceAccount:mcp-music-library-sa@$PROJECT_ID.iam.gserviceaccount.com" \
    --role="roles/secretmanager.secretAccessor"

gcloud secrets add-iam-policy-binding db-port \
    --member="serviceAccount:mcp-music-library-sa@$PROJECT_ID.iam.gserviceaccount.com" \
    --role="roles/secretmanager.secretAccessor"

echo "Setup complete!"
echo "GCS Bucket: $BUCKET_NAME"
echo "Cloud SQL Instance: mcp-music-library-db"
echo "Database: music_library"
echo "User: music_library_user"
echo "Password: $DB_PASSWORD (also stored in Secret Manager)"
echo "Bearer Token: stored in Secret Manager as 'mcp-bearer-token'"
```

# Test Strategy:
1. Verify Docker container builds successfully
2. Test Cloud Run deployment with minimal configuration
3. Validate environment variables and secrets are correctly set
4. Test HTTPS and domain mapping
5. Verify Cloud SQL connection works in production
6. Test GCS bucket permissions
7. Validate health checks and monitoring
8. Test cold start performance
9. Verify timeout configuration works for long-running processes
10. Test end-to-end functionality in production environment

# Subtasks:
## 1. Dockerfile Creation and Optimization [done]
### Dependencies: None
### Description: Create a production-ready Dockerfile following best practices including multi-stage builds, minimal base images, proper layer caching, and security considerations
### Details:
Develop Dockerfile with optimized build instructions, use appropriate base image (Alpine or distroless), implement multi-stage builds to reduce image size, define environment variables with ENV, create .dockerignore file to exclude sensitive data and unnecessary files, ensure reproducible builds by specifying exact package versions, and validate the container runs stateless and ephemeral
<info added on 2025-10-31T16:17:49.426Z>
Successfully completed Dockerfile creation and optimization for Cloud Run deployment. Key improvements implemented:

✅ Created comprehensive .dockerignore file to exclude sensitive data, development files, and unnecessary build context
✅ Switched to Alpine Linux base images (python:3.11-alpine) for significantly smaller image size
✅ Implemented multi-stage build with separate builder and runtime stages for optimal layer caching
✅ Added distroless stage as alternative ultra-minimal option (gcr.io/distroless/python3-debian12:nonroot)
✅ Enhanced security with non-root user (fastmcpuser), proper file permissions (644/755), and cleaned build artifacts
✅ Added security hardening environment variables and ensured stateless/ephemeral container design
✅ Optimized health check timing for production (30s start period)
✅ Resolved psutil compilation issues by adding linux-headers to builder stage
✅ Tested successful build and runtime functionality - container starts and imports FastMCP server correctly

The optimized Dockerfile now follows production best practices with three stages: builder (Alpine), runtime (Alpine), and distroless (ultra-minimal alternative). Image size significantly reduced while maintaining full functionality and security hardening.
</info added on 2025-10-31T16:17:49.426Z>

## 2. Container Build and Registry Push [done]
### Dependencies: 12.1
### Description: Build the Docker container image using Cloud Build and push to Artifact Registry for deployment
### Details:
Set up Artifact Registry repository, navigate to project directory with Dockerfile, execute 'gcloud builds submit --tag IMAGE_URL' to build on Google Cloud, verify image is pushed to registry with proper tagging convention (LOCATION-docker.pkg.dev/PROJECT_ID/REPO_NAME/PATH:TAG), implement image vulnerability scanning in CI/CD pipeline using security tools, and optimize build performance by leveraging cache
<info added on 2025-10-31T16:22:11.758Z>
Successfully completed container build and registry push setup with comprehensive CI/CD pipeline optimizations:

1. Artifact Registry Setup Script (scripts/create-artifact-registry.sh):
   - Automated repository creation with proper configuration
   - IAM permissions for service accounts
   - Cleanup policies for image lifecycle management
   - Docker authentication setup
   - Test image build and push validation

2. Vulnerability Scanning Integration in cloudbuild.yaml:
   - Automated scanning post-image push
   - Critical/high severity vulnerability detection and reporting
   - Non-blocking alerts with detailed vulnerability information
   - Integration with Google Cloud's Container Analysis

3. Cloud Build Performance Optimization:
   - BuildKit enabled for faster builds
   - Layer caching using --cache-from for incremental builds
   - High-performance N1_HIGHCPU_32 machine type
   - Increased disk space (200GB)
   - Optimized Docker daemon environment variables

4. Comprehensive Image Tagging Strategy:
   - Commit SHA tagging for version tracking
   - Latest tag for development
   - Timestamp tags for chronological ordering
   - Branch-based tags for multi-environment deployments
   - Automatic cleanup policies for old images

5. Build Process Validation Script (scripts/test-container-build.sh):
   - Multi-stage build verification
   - Security feature validation (non-root user, permissions)
   - Dockerfile optimization assessment
   - Image size and performance analysis
   - Automated test reporting
</info added on 2025-10-31T16:22:11.758Z>

## 3. Environment Variable Configuration [done]
### Dependencies: 12.1
### Description: Set up environment variables for the Cloud Run service to configure application runtime behavior
### Details:
Define all non-sensitive configuration variables needed by the application, create environment variable definitions for Cloud Run service (database connection strings without credentials, feature flags, API endpoints, logging levels), use ENV instructions in Dockerfile for default values, and document all environment variables with descriptions for team reference
<info added on 2025-10-31T16:34:32.951Z>
Successfully completed comprehensive environment variable configuration for Cloud Run deployment. This subtask established a complete, production-ready environment variable system across all deployment methods.

✅ **Dockerfile Environment Variables**: Updated both runtime and distroless stages with comprehensive ENV definitions covering:
   - Server identity (name, version, instructions)
   - Server runtime (host, port, transport)
   - Logging configuration (level, format)
   - MCP protocol settings
   - Duplicate handling policies
   - Performance tuning (workers, timeouts)
   - Storage configuration
   - GCS settings (non-sensitive)
   - Database settings (non-sensitive)
   - CORS configuration
   - Embed settings
   - Feature flags
   - Python runtime security hardening

✅ **Cloud Build Environment Variables**: Enhanced cloudbuild.yaml with complete environment variable definitions for production deployment:
   - Comprehensive set-env-vars covering all application configuration
   - Proper grouping by functional areas
   - Production-optimized default values
   - Sensitive data handled via secrets (--update-secrets flags)

✅ **Environment Variable Documentation**: Created comprehensive documentation (docs/environment-variables.md) including:
   - Complete variable reference with descriptions, defaults, and examples
   - Security considerations and secret management guidance
   - Deployment examples for different environments (local dev, Cloud Run, .env files)
   - Configuration loading priority and validation information

✅ **Configuration Validation**: Developed validation framework (scripts/validate-env-config.sh) that verifies:
   - Dockerfile ENV structure and critical variables
   - Cloud Build environment variable definitions
   - Docker Compose basic configuration
   - Python configuration loading and attribute access
   - Environment variable override functionality
   - Documentation completeness

The environment variable configuration is now production-ready with proper security separation, comprehensive documentation, and validation across all deployment methods (Docker, Docker Compose, Cloud Run). The system supports flexible configuration with environment-specific overrides while maintaining security best practices for sensitive data management.
</info added on 2025-10-31T16:34:32.951Z>

## 4. Secret Management Implementation [done]
### Dependencies: 12.3
### Description: Configure secure secret management using Google Cloud Secret Manager for sensitive credentials and API keys
### Details:
Create secrets in Google Cloud Secret Manager for database passwords, API keys, and other sensitive data, configure IAM permissions to allow Cloud Run service account to access specific secrets, set up secret mounting or environment variable injection for Cloud Run, ensure secrets are never exposed in Dockerfile or version control, implement secret rotation policies, and validate secret access from running containers
<info added on 2025-10-31T17:04:09.606Z>
# Google Cloud Secret Manager Implementation Research

## Secret Creation & Storage
- Use Secret Manager as authoritative source for sensitive data (database credentials, API keys, etc.)
- Implement descriptive naming conventions (e.g., "production-database-credentials" vs generic names)
- Choose between automatic replication (recommended for most cases) or regional secrets (for data residency requirements)
- Limit secret versions (first 6 are free, additional cost $0.06/month per version per location)

## IAM Permissions
- Create dedicated service accounts with minimal required permissions (least privilege)
- Use predefined roles: Secret Manager Secret Accessor (most common), Admin, etc.
- Apply IAM bindings at individual secret level, not project level
- Use IAM Conditions for attribute-based access control

## Secret Injection Methods
- **Volume mounting (recommended)**: Secrets available as files, auto-fetches latest version on read
- **Environment variables**: Secrets injected at startup, pin to specific versions (not "latest")
- Volume mounting better for secrets that change during runtime
- Environment variables better for startup-time secrets

## Security Best Practices
- Never store secrets in source code, Dockerfiles, or container images
- Use Application Default Credentials (ADC) for authentication
- Implement proper logging sanitization to avoid exposing secrets
- Use VPC Service Controls for network-based restrictions
- Enable Cloud Audit Logs for comprehensive access tracking

## Secret Rotation
- Implement automated rotation using Pub/Sub notifications
- Create Cloud Run services that handle rotation logic
- Support gradual rollout strategies to minimize service disruption
- Test rotation workflows in staging before production

## Testing & Validation
- Mock Secret Manager in unit tests
- Test IAM permissions during deployment validation
- Perform integration testing with actual secrets in staging
- Validate rotation automation and rollback scenarios

## Production Patterns for MCP Servers
- Use dedicated service accounts with minimal permissions
- Store API keys, database credentials, auth tokens in Secret Manager
- Implement authentication at Cloud Run level (OIDC tokens)
- Use volume mounting for dynamic secret access
- Enable audit logging for compliance and monitoring
</info added on 2025-10-31T17:04:09.606Z>
<info added on 2025-10-31T17:04:40.801Z>
# Secret Manager Implementation Completed

## Implementation Details
- Created comprehensive setup script: `scripts/create-secrets.sh`
- Implemented secure password generation using OpenSSL
- Configured dedicated service account with least-privilege IAM roles
- Applied granular access control at individual secret level
- Enabled audit logging for compliance and security monitoring

## Secrets Configuration
**Database Secrets:**
- db-connection-name: Cloud SQL connection string
- db-user: Application database user
- db-password: Securely generated password
- db-name: Database name
- db-host: Host configuration
- db-port: PostgreSQL port

**Storage Secrets:**
- gcs-bucket-name: GCS bucket identifier

**Authentication Secrets:**
- mcp-bearer-token: HTTP authentication token

## Cloud Build Integration
- Configured substitution variables: _DB_CONNECTION_NAME, _GCS_BUCKET_NAME
- Implemented --update-secrets flags in cloudbuild.yaml
- Supports both volume mounting and environment variable injection methods

## Validation & Testing
- Created `scripts/validate-secrets.sh` for testing secret access
- Implemented service account verification
- Added IAM permission validation checks
- Provided access testing commands for deployment verification

All implementation follows Google Cloud Secret Manager best practices and provides production-ready secret management for the MCP server deployment.
</info added on 2025-10-31T17:04:40.801Z>
<info added on 2025-10-31T17:04:52.016Z>
# IAM Permissions Configuration

## Service Account Configuration
- Created dedicated service account: `mcp-music-library-sa@$PROJECT_ID.iam.gserviceaccount.com`
- Configured with least-privilege access principle
- Added descriptive metadata and purpose documentation

## IAM Roles Granted
- **Secret Manager Secret Accessor**: Access to all required secrets
- **Cloud SQL Client**: Database connectivity permissions
- **Storage Object Admin**: GCS bucket operations permissions

## Granular Access Control
- Applied permissions at individual secret level (not project-wide)
- Specific access granted to: db-connection-name, db-user, db-password, db-name, db-host, db-port, gcs-bucket-name, mcp-bearer-token
- Follows principle of least privilege for security hardening

## Security Benefits
- Service account isolation prevents cross-service credential sharing
- Granular permissions limit blast radius if compromised
- Audit trail available through Cloud Audit Logs
- Compatible with VPC Service Controls for additional network restrictions
</info added on 2025-10-31T17:04:52.016Z>
<info added on 2025-10-31T17:05:54.891Z>
# Cloud Build Secret Injection Configuration

## Production Cloud Build Updates (cloudbuild.yaml)
- Added `--update-secrets=BEARER_TOKEN=${_BEARER_TOKEN}:latest` for authentication secret injection
- Added `_BEARER_TOKEN: 'mcp-bearer-token'` to substitutions for secret name mapping
- Existing DB and GCS secret injections already properly configured

## Staging Cloud Build Updates (cloudbuild-staging.yaml)
- Added `--update-secrets=BEARER_TOKEN=${_BEARER_TOKEN_STAGING}:latest` for staging authentication
- Added `_BEARER_TOKEN_STAGING: 'mcp-bearer-token-staging'` to substitutions
- Maintains separate staging environment secrets for isolation

## Secret Injection Strategy
- **Environment Variables**: Used for all secrets (DB_CONNECTION_NAME, GCS_BUCKET_NAME, BEARER_TOKEN)
- **Version Pinning**: All secrets use `:latest` version for automatic updates
- **Multi-Environment Support**: Separate secrets for production and staging
- **Service Account Integration**: Secrets injected using dedicated Cloud Run service account

## Security Architecture
- Secrets never exposed in build logs or source code
- Service account has least-privilege access to specific secrets
- Audit logging enabled through Cloud Audit Logs
- Compatible with VPC Service Controls for additional network restrictions
</info added on 2025-10-31T17:05:54.891Z>
<info added on 2025-10-31T17:07:05.121Z>
# Secret Rotation Implementation

## Rotation Documentation (docs/secret-rotation-guide.md)
- **Complete rotation guide** covering all secret types and rotation strategies
- **Automated vs manual procedures** for different scenarios
- **Pub/Sub-based rotation architecture** using Google Cloud native capabilities
- **Database password rotation** workflows with Cloud SQL integration
- **Bearer token rotation** procedures with client update guidance
- **Monitoring and alerting** configurations for rotation events
- **Gradual rollout strategies** to minimize service disruption
- **Incident response procedures** for rotation failures

## Rotation Automation Script (scripts/rotate-secrets.py)
- **Python-based automation** for different secret types
- **Bearer token rotation**: Automated generation and secret version creation
- **Database password rotation**: Integrated Cloud SQL user updates
- **Dry-run capability** for testing rotation procedures
- **Secret information queries** for monitoring and auditing
- **Version cleanup utilities** to manage secret history
- **Comprehensive logging** and error handling

## Rotation Strategies Implemented
- **Bearer Tokens**: Monthly rotation with automated procedures
- **Database Passwords**: Quarterly rotation with manual oversight
- **Multi-environment support**: Separate procedures for production/staging
- **Gradual deployment**: Blue-green strategies for credential updates

## Monitoring and Compliance
- **Cloud Audit Logs integration** for all rotation activities
- **Cloud Monitoring alerts** for rotation failures and anomalies
- **Compliance documentation** for regulatory requirements
- **Operational runbooks** for manual rotation procedures

## Security Enhancements
- **Principle of least privilege** in rotation service accounts
- **Audit trails** for all credential lifecycle events
- **Rollback procedures** for failed rotations
- **Testing frameworks** for rotation validation
</info added on 2025-10-31T17:07:05.121Z>
<info added on 2025-10-31T17:07:19.004Z>
# Secret Validation Implementation

## Validation Script (scripts/validate-secrets.sh)
- **Complete validation framework** for all secret access scenarios
- **Service account verification** ensuring proper IAM configuration
- **Secret existence checks** for all required secrets
- **Permission validation** testing actual access capabilities
- **Multi-environment support** for production and staging secrets
- **Automated testing commands** for integration verification

## Container Validation Features
- **Health check integration** with Cloud Run deployment verification
- **Secret injection testing** during container startup
- **Permission failure detection** with clear error reporting
- **Access pattern validation** for different secret types
- **Deployment pipeline integration** for automated testing

## Testing Capabilities
- **Pre-deployment validation** before Cloud Build execution
- **Post-deployment verification** after Cloud Run service updates
- **Access testing commands** for manual verification
- **Failure diagnostics** with actionable error messages
- **Integration with CI/CD** pipeline for automated quality gates

## Security Validation
- **IAM policy verification** ensuring least-privilege access
- **Secret isolation testing** between production and staging
- **Audit logging validation** for compliance verification
- **Access pattern monitoring** for anomaly detection

The validation framework ensures secrets are properly configured, accessible, and secure before and after deployment, providing confidence in the secret management implementation.
</info added on 2025-10-31T17:07:19.004Z>

## 5. Cloud Run Service Configuration [pending]
### Dependencies: 12.2, 12.4
### Description: Deploy and configure the Cloud Run service with proper resource limits, scaling parameters, and networking settings
### Details:
Deploy container image to Cloud Run, declare resource requirements (CPU, memory limits and requests) to prevent infinite resource utilization and control costs, configure autoscaling parameters (min/max instances, concurrency), set request timeout and startup timeout values, configure service account with least-privilege IAM permissions, enable VPC connector if needed for private resources, and set up traffic splitting for blue-green deployments if required

## 6. Cloud SQL Connection Setup [pending]
### Dependencies: 12.5
### Description: Configure secure connection between Cloud Run service and Cloud SQL database instance
### Details:
Enable Cloud SQL Admin API, configure Cloud SQL connection using Unix socket (recommended) or TCP with Cloud SQL Proxy, add Cloud SQL connection string to Cloud Run service configuration, grant Cloud SQL Client IAM role to Cloud Run service account, configure connection pooling parameters, implement connection retry logic in application code, and test database connectivity from deployed service

## 7. GCS Permissions and Storage Configuration [pending]
### Dependencies: 12.5
### Description: Set up Google Cloud Storage bucket access with proper IAM permissions for the Cloud Run service
### Details:
Create or identify GCS buckets needed by the application, grant appropriate IAM roles to Cloud Run service account (Storage Object Viewer, Creator, or Admin based on requirements), configure bucket-level or object-level permissions, implement signed URLs for secure temporary access if needed, set up lifecycle policies for data retention, and validate read/write operations from the deployed service

## 8. HTTPS and Custom Domain Mapping [pending]
### Dependencies: 12.5
### Description: Configure custom domain mapping with automatic HTTPS certificate provisioning for the Cloud Run service
### Details:
Verify domain ownership in Google Cloud Console, map custom domain to Cloud Run service, configure DNS records (A or CNAME) to point to Cloud Run endpoints, enable automatic SSL/TLS certificate provisioning through Google-managed certificates, verify HTTPS is enforced and HTTP redirects properly, set up domain verification for additional domains if needed, and test domain resolution and certificate validity

## 9. Health Checks and Monitoring Setup [pending]
### Dependencies: 12.5
### Description: Implement application health checks and configure comprehensive monitoring with Cloud Monitoring and logging
### Details:
Implement /health or /readiness endpoint in application code, configure Cloud Run startup and liveness probes, set up Cloud Monitoring dashboards for key metrics (request latency, error rates, instance count, CPU/memory usage), configure log aggregation in Cloud Logging with appropriate filters, create alerting policies for critical thresholds (error rate spikes, high latency, resource exhaustion), enable Cloud Trace for request tracing, and set up uptime checks for availability monitoring

## 10. End-to-End Deployment Validation [completed]
### Dependencies: 12.6, 12.7, 12.8, 12.9
### Description: Perform comprehensive testing and validation of the entire production deployment to ensure all components work together correctly
### Details:
Execute smoke tests against deployed service endpoints, validate HTTPS access through custom domain, test database operations (read/write to Cloud SQL), verify GCS file operations (upload/download), confirm environment variables and secrets are properly injected, simulate load testing to validate autoscaling behavior, review monitoring dashboards and verify metrics collection, test health check endpoints respond correctly, validate logging output and error tracking, perform security audit of IAM permissions, and document deployment procedure and rollback steps

